import{_ as a,o as e,c as t,V as i}from"./chunks/framework.7cbf217e.js";const l="/assets/image-20230414181133732.37f58fa1.png",o="/assets/image-20230414181520748.37df8b6e.png",f=JSON.parse('{"title":"CSS特性","description":"","frontmatter":{},"headers":[],"relativePath":"front-end/CSS/基础/10-CSS特性.md","filePath":"front-end/CSS/基础/10-CSS特性.md","lastUpdated":1683117492000}'),r={name:"front-end/CSS/基础/10-CSS特性.md"},s=i('<h1 id="css特性" tabindex="-1">CSS特性 <a class="header-anchor" href="#css特性" aria-label="Permalink to &quot;CSS特性&quot;">​</a></h1><h2 id="层叠性" tabindex="-1">层叠性 <a class="header-anchor" href="#层叠性" aria-label="Permalink to &quot;层叠性&quot;">​</a></h2><p>相同选择器给设置相同的样式，此时一个样式就会覆盖（层曼）另一个冲突的样式。层叠性主要解决样式冲突的问题</p><blockquote><p>层叠性原则:</p><ul><li>样式冲突，遵循的原则是就近原则，哪个样式离结构近，就执行哪个样式</li><li>样式不冲突，不会层叠</li></ul></blockquote><h2 id="继承性" tabindex="-1">继承性 <a class="header-anchor" href="#继承性" aria-label="Permalink to &quot;继承性&quot;">​</a></h2><p>CSS中的继承:子标签会继承父标签的某些样式，如文本颜色和字号。简单的理解就是∶子承父业。</p><p>恰当地使用继承可以简化代码，降低CSS样式的复杂性</p><p>子元素可以继承父元素的样式( text-, font-, line-这些元素开头的可以继承，以及color属性)</p><h3 id="行高的继承性" tabindex="-1">行高的继承性 <a class="header-anchor" href="#行高的继承性" aria-label="Permalink to &quot;行高的继承性&quot;">​</a></h3><p><img src="'+l+'" alt="image-20230414181133732"></p><ul><li>行高可以跟单位也可以不跟单位</li><li>如果子元素没有设置行高，则会继承父元素的行高为1.5</li><li>此时子元素的行高是:当前子元素的文字大小*1.5</li><li>body行高1.5这样写法最大的优势就是里面子元素可以根据自己文字大小自动调整行高</li></ul><h2 id="优先级" tabindex="-1">优先级 <a class="header-anchor" href="#优先级" aria-label="Permalink to &quot;优先级&quot;">​</a></h2><p><img src="'+o+'" alt="image-20230414181520748"></p><blockquote><ul><li>权重是有4组数字组成但是不会有进位。</li><li>可以理解为类选择器永远大于元素选择器, id选择器永远大于类选择器,以此类推..</li><li>等级判断从左向右，如果某一位数值相同，则判断下一位数值</li><li>可以简单记忆法:通配符和继承权重为0,标签选择器为1,类(伪类)选择器为10, id选择器100,行内样式表为1000,!important无穷大</li><li>继承的权重是0，如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是0.</li></ul></blockquote>',14),n=[s];function c(d,_,h,p,S,u){return e(),t("div",null,n)}const b=a(r,[["render",c]]);export{f as __pageData,b as default};
